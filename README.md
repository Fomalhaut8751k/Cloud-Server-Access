# 基于连接池的云服务器访问
## 0. 功能点
在c++连接池项目的基础上，进行修改和增进：
- 1.将申请连接的用户分为**普通用户**和**vip用户**，它们在申请连接时，连接池系统会根据身份作出不同行为：
    - 当连接池中尚有空闲连接，则普通用户和vip用户都可以直接申请
    - 当连接池中没有空闲连接，但总的连接数量小于maxSize时，普通用户需要排队，而vip用户可以为它们额外生产新的连接
    - 当连接池中没有空闲连接，且总的连接数量不小于maxSize时，普通用户和vip用户都需要排队，但vip用户享有特殊排队通道，即如果有回收的空闲连接，优先分配给在排队的vip用户，直到没有vip用户在排队再考虑普通用户

- 2.用户可以选择退出排队：当用户处在排队等待状态时，它可以退出排队

- 3.用户占据连接但长时间未操作时，连接池会自动回收它的连接

## 1. 连接池功能点介绍

连接池一般包含了数据库连接所用的ip地址、port端口号、用户名和密码以及其它的性能参数，例如初始连接量，最大连接量，最大空闲时间、连接超时时间等，该项目是基于C++语言实现的连接池，主要也是实现以上几个所有连接池都支持的通用基础功能。

**初始连接量（initSize）**：表示连接池事先会和MySQL Server创建initSize个数的connection连接，当应用发起MySQL访问时，不用再创建和MySQL Server新的连接，直接从连接池中获取一个可用的连接就可以，使用完成后，并不去释放connection，而是把当前connection再归还到连接池当中。

**最大连接量（maxSize）**：当并发访问MySQL Server的请求增多时，初始连接量已经不够使用了，此时会根据新的请求数量去创建更多的连接给应用去使用，但是新创建的连接数量上限是maxSize，不能无限制的创建连接，因为每一个连接都会占用一个socket资源，一般连接池和服务器程序是部署在一台主机上的，如果连接池占用过多的socket资源，那么服务器就不能接收太多的客户端请求了。当这些连接使用完成后，再次归还到连接池当中来维护。

**最大空闲时间（maxIdleTime）**：当访问MySQL的并发请求多了以后，连接池里面的连接数量会动态增加，上限是maxSize个，当这些连接用完再次归还到连接池当中。如果在指定的maxIdleTime里面，这些新增加的连接都没有被再次使用过，那么新增加的这些连接资源就要被回收掉，只需要保持初始连
接量initSize个连接就可以了。

**~~连接超时时间（connectionTimeout）~~**

## 2. 功能实现设计 

新的功能点：用户分为普通用户和vip用户，普通用户和vip用户共享初始连接量的连接。当并发量较大时，申请量超过空闲连接时，__即超过初始连接量的连接只提供给vip用户__。会额外创建新的连接供vip用户申请，总的连接不超过最大连接量。当没有空闲的连接供对应类型的用户时，会进入排队等待状态，轮到后可以正常申请连接。

(可选项): 排队时，vip用户无论顺序都排在普通用户前面，可以优先申请连接。

连接池主要包含了以下功能点： 

- 1.连接池只需要一个实例，所以ConnectionPool以单例模式进行设计。 

- 2.从ConnectionPool中可以获取和MySQL的连接Connection。

- 3.空闲连接Connection全部维护在一个线程安全的Connection队列中，使用线程互斥锁保证队列的线程安全。 

- 4.如果Connection队列为空，还需要再获取连接，此时需要动态创建连接，上限数量是maxSize。 

- 5.队列中空闲连接时间超过maxIdleTime的就要被释放掉，只保留初始的initSize个连接就可以了，这个功能点肯定需要放在独立的线程中去做。 

- 6.如果Connection队列为空，而此时连接的数量已达上限maxSize，那么等待connectionTimeout时间，如果还获取不到空闲的连接，那么获取连接失败，此处从Connection队列获取空闲连接，可以使用带超时时间的mutex互斥锁来实现连接超时时间。 

- 7.用户获取的连接用shared_ptr智能指针来管理，用lambda表达式定制连接释放的功能（不真正释放连接，而是把连接归还到连接池中）。 

- 8.连接的生产和连接的消费采用生产者-消费者线程模型来设计，使用了线程间的同步通信机制条件变量和互斥锁。


## 3. 压力测试
使用连接池技术 vs 不使用连接池技术

简单模拟用户行为，包括排队时选择退出排队，申请到连接后闲置等待系统回收连接。

- 用户创建时传入随机的标签，如果为true，且用户发起连接申请5s后没有获取到连接(还在排队)，则退出排队(随机的标签模拟一部分用户的选择)
- 10s未操作，则由连接池回收连接。

 _总耗时_ ( _没有申请到连接的人数_ / _申请到连接的人数_ )
，没有申请到连接————中途退出排队。
  
- _initSize = 10, _maxSize = 20
  |  总申请人数 |     |      |      |
  | -------- | -------- | -------- | -------- |
  | 20 | 25108ms(3/17) | 25066ms(1/19) | 25055ms(4/16) |
  |  | __20168ms(3/17)__ | __20081ms(1/19)__ | __20072ms(2/18)__ | 
  | 80 | 45198ms(33/47) | 45153ms(31/49) | 55219ms(25/55) |
   |  | __30126ms(33/47)__ | __30122ms(31/49)__ |  __35134ms(25/55)__ |
  | 200 | 95233ms(89/111) | 85308ms(92/108) | 85272ms(97/103) |
  |  | __60448ms(89/111)__ | __60261ms(93/107)__ | __60213ms(98/102)__ |
  | 500 | 205756ms(255/245) | 195922ms(241/259) |206066ms(234/266) |
  |  | __130364ms(253/247)__ | __135350ms(246/254)__ | __135421ms(241/259)__|
  |  |  | | |

- _initSize = 60, _maxSize = 80
  |  总申请人数 |     |      |      |
    | -------- | -------- | -------- | -------- |
    | 20 | 15045ms(0/20) | 15031ms(0/20) | 15124ms(0/20) |
    |  | __15070ms(0/20)__ | __15076ms(0/20)__ | __15075ms(0/20)__ | 
    | 80 | 25076ms(8/72) | 25100ms(4/76) | 25088ms(5/75) |
    |  | __20109ms(6/74)__ | __20118ms(4/76)__ |  __20120ms(5/75)__ |
    | 200 | 35083ms(57/143) | 35118ms(58/142) | 35113ms(55/145) |
    |  | __25119ms(51/149)__ | __25093ms(58/142)__ | __25095ms(55/145)__ |
    | 500 | 55221ms(202/298) | 55168ms(193/307) |55236ms(214/286) |
    |  | __40507ms(216/284)__ | __40305ms(232/268)__ | __40304ms(210/290)__|
    |  |  | | |

  不使用连接池技术，在每一次申请内存时，确认满足所有申请条件时，当场创建连接并链接mysql数据库，并且不会实现开辟连接。
  ```cpp
    Connection* p = new Connection();
	p->connect(_ip, _port, _username, _password, _dbname);
  ```
  
  - 当_initSize足够大，如情况_initSize = 60, _maxSize = 80且总申请人数只有20时，所有用户都可以立即申请到连接，不需要排队等待其他用户使用完成，故不涉及回收(使用连接池技术的优势，省略了连接的析构，连接的创建，连接与mysql的链接)，因此连接池技术的使用与否不影响性能。

  - 当申请连接的用户量过大时，大批用户需要进行排队等待，等待其他用户使用完毕，进行析构，然后系统为满足申请条件的用户创建连接，包括new和链接mysql数据集。相比于这种不够高效的操作，使用连接池技术时，在用户使用完毕后仅仅是归还连接到连接池，并没有析构再构造等操作，直接给到等待的用户使用，因此效率更高。